"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const axios_1 = __importDefault(require("axios"));
const minimist_1 = __importDefault(require("minimist"));
const fs_1 = require("fs");
const form_data_1 = __importDefault(require("form-data"));
const path_1 = require("path");
const validation_1 = require("./validation");
// TODO: implement via the base client
const XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
class Client {
    constructor(config) {
        const { configFile } = config, restConfig = __rest(config, ["configFile"]);
        let finalConfig = restConfig;
        if (configFile) {
            finalConfig = Client.mergeConfig(finalConfig, this.readConfigFile(configFile));
        }
        finalConfig = Client.mergeConfig(finalConfig, this.readEnvConfig());
        finalConfig = Client.mergeConfig(finalConfig, this.readCliConfig());
        this.config = (0, validation_1.validateConfig)(finalConfig);
        const baseURL = new URL('/api/v2', this.config.url).toString();
        this.axios = axios_1.default.create({
            baseURL,
            headers: {
                Authorization: `PrivateToken ${this.config.privateToken}`,
            },
        });
        // TODO: implement via the base client
        this.request = new XMLHttpRequest();
    }
    async checkConnection() {
        try {
            await axios_1.default.get(new URL('version.json', this.config.url).toString());
        }
        catch (err) {
            throw new Error('Cannot connect to TestIt');
        }
    }
    // TODO: add query object
    async getAutotest(query) {
        const params = new URLSearchParams();
        Object.keys(query).forEach((key) => {
            const value = query[key];
            if (value === undefined) {
                return;
            }
            if (Array.isArray(value)) {
                value.forEach((v) => params.append(key, v));
            }
            else {
                params.append(key, value.toString());
            }
        });
        return this.axios
            .get(`/autoTests?${params.toString()}`)
            .then((res) => res.data);
    }
    async createAutotest(autotest) {
        return this.axios.post('/autoTests', autotest).then((res) => res.data);
    }
    async updateAutotest(autotest) {
        return this.axios.put('/autoTests', autotest);
    }
    async linkToWorkItem(autotestId, workItem) {
        return this.axios.post(`/autoTests/${autotestId}/workItems`, workItem);
    }
    // TODO: implement via the base client
    getTestRun(testRunId) {
        const baseURL = new URL('/api/v2', this.config.url).toString();
        this.request.open("GET", `${baseURL}/testRuns/${testRunId}`, false);
        this.request.setRequestHeader('Authorization', `PrivateToken ${this.config.privateToken}`);
        this.request.send(null);
        return JSON.parse(this.request.responseText);
    }
    async createTestRun(testRun) {
        return this.axios
            .post('/testRuns', testRun)
            .then((res) => res.data);
    }
    async startTestRun(testRunId) {
        return this.axios.post(`/testRuns/${testRunId}/start`);
    }
    async loadTestRunResults(testRunId, results) {
        return await this.axios
            .post(`/testRuns/${testRunId}/testResults`, results)
            .then((res) => res.data);
    }
    async completeTestRun(testRunId) {
        return this.axios.post(`/testRuns/${testRunId}/complete`);
    }
    getConfig() {
        return this.config;
    }
    async loadAttachment(filePath) {
        const form = new form_data_1.default();
        form.append('file', (0, fs_1.readFileSync)(filePath), (0, path_1.basename)(filePath));
        return this.axios
            .post('/Attachments', form, {
            headers: form.getHeaders(),
        })
            .then((res) => res.data);
    }
    readCliConfig() {
        const args = (0, minimist_1.default)(process.argv.slice(2));
        let config = {};
        if (args['testitConfig']) {
            config = this.readConfigFile(args['testitConfig']);
        }
        return Client.mergeConfig(config, {
            url: args['testitUrl'],
            privateToken: args['testitPrivateToken'],
            projectId: args['testitProjectId'],
            configurationId: args['testitConfigurationId'],
            testRunId: args['testitTestRunId'],
        });
    }
    readEnvConfig() {
        let config = {};
        if (process.env['TESTIT_CONFIG_FILE']) {
            config = this.readConfigFile(process.env['TESTIT_CONFIG_FILE']);
        }
        return Client.mergeConfig(config, {
            url: process.env['TESTIT_URL'],
            privateToken: process.env['TESTIT_PRIVATE_TOKEN'],
            projectId: process.env['TESTIT_PROJECT_ID'],
            configurationId: process.env['TESTIT_CONFIGURATION_ID'],
            testRunId: process.env['TESTIT_TEST_RUN_ID'],
        });
    }
    readConfigFile(path) {
        if (!(0, fs_1.existsSync)(path)) {
            throw new Error('Config file not found');
        }
        const config = JSON.parse((0, fs_1.readFileSync)(path, { encoding: 'utf8' }));
        if (config.privateToken) {
            console.warn('Private token is in config file, it is not secure');
        }
        return config;
    }
    static mergeConfig(oldConfig, newConfig) {
        var _a, _b, _c, _d, _e;
        return {
            url: (_a = newConfig.url) !== null && _a !== void 0 ? _a : oldConfig.url,
            privateToken: (_b = newConfig.privateToken) !== null && _b !== void 0 ? _b : oldConfig.privateToken,
            projectId: (_c = newConfig.projectId) !== null && _c !== void 0 ? _c : oldConfig.projectId,
            configurationId: (_d = newConfig.configurationId) !== null && _d !== void 0 ? _d : oldConfig.configurationId,
            testRunId: (_e = newConfig.testRunId) !== null && _e !== void 0 ? _e : oldConfig.testRunId,
        };
    }
}
exports.Client = Client;
