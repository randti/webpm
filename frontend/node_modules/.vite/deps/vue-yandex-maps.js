import "./chunk-TWLJ45QX.js";

// node_modules/vue-yandex-maps/dist/vue-yandex-maps.esm.js
function e(e3, t2) {
  var o2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e3, t3).enumerable;
    })), o2.push.apply(o2, n2);
  }
  return o2;
}
function t(t2) {
  for (var o2 = 1; o2 < arguments.length; o2++) {
    var n2 = null != arguments[o2] ? arguments[o2] : {};
    o2 % 2 ? e(Object(n2), true).forEach(function(e3) {
      r(t2, e3, n2[e3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(n2)) : e(Object(n2)).forEach(function(e3) {
      Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(n2, e3));
    });
  }
  return t2;
}
function o(e3) {
  return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
    return typeof e4;
  } : function(e4) {
    return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
  })(e3);
}
function n(e3, t2) {
  for (var o2 = 0; o2 < t2.length; o2++) {
    var n2 = t2[o2];
    n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
  }
}
function r(e3, t2, o2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: o2, enumerable: true, configurable: true, writable: true }) : e3[t2] = o2, e3;
}
function a(e3) {
  return function(e4) {
    if (Array.isArray(e4))
      return i(e4);
  }(e3) || function(e4) {
    if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"])
      return Array.from(e4);
  }(e3) || function(e4, t2) {
    if (!e4)
      return;
    if ("string" == typeof e4)
      return i(e4, t2);
    var o2 = Object.prototype.toString.call(e4).slice(8, -1);
    "Object" === o2 && e4.constructor && (o2 = e4.constructor.name);
    if ("Map" === o2 || "Set" === o2)
      return Array.from(e4);
    if ("Arguments" === o2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o2))
      return i(e4, t2);
  }(e3) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function i(e3, t2) {
  (null == t2 || t2 > e3.length) && (t2 = e3.length);
  for (var o2 = 0, n2 = new Array(t2); o2 < t2; o2++)
    n2[o2] = e3[o2];
  return n2;
}
function s(e3, o2) {
  var n2 = o2.options, r2 = o2.callbacks, i2 = o2.map, s2 = o2.useObjectManager, l2 = o2.objectManagerClusterize, c2 = o2.useHtmlInLayout ? '\n    <div v-html="properties.balloonContentHeader"></div>\n    <div v-html="properties.balloonContentBody"></div>\n    <div v-html="properties.balloonContentFooter"></div>\n  ' : "\n    <div>{{ properties.balloonContentHeader }}</div>\n    <div>{{ properties.balloonContentBody }}</div>\n    <div>{{ properties.balloonContentFooter }}</div>\n  ", u2 = {}, p2 = [];
  if (e3.forEach(function(e4) {
    e4.clusterName ? u2[e4.clusterName] = u2[e4.clusterName] ? [].concat(a(u2[e4.clusterName]), [e4]) : [e4] : p2.push(e4);
  }), Object.keys(u2).forEach(function(e4) {
    var o3 = t({}, n2[e4]) || {}, a2 = r2[e4] || {}, p3 = o3.layout || c2;
    o3.clusterBalloonItemContentLayout = ymaps.templateLayoutFactory.createClass(p3);
    var m3 = o3.clusterBalloonLayout || o3.clusterLayout;
    delete o3.clusterBalloonLayout;
    var d2 = m3 ? ymaps.templateLayoutFactory.createClass(m3) : o3.clusterBalloonContentLayout || "cluster#balloonTwoColumns";
    o3.clusterBalloonContentLayout = d2;
    var f2 = o3.clusterIconContentLayout;
    if (o3.clusterIconContentLayout = f2 && ymaps.templateLayoutFactory.createClass(f2), s2) {
      var y2 = new ymaps.ObjectManager(Object.assign({ clusterize: l2 }, o3));
      Object.keys(a2).forEach(function(e5) {
        y2.clusters.events.add(e5, a2[e5]);
      }), y2.add(u2[e4]), i2.geoObjects.add(y2);
    } else {
      var h2 = new ymaps.Clusterer(o3);
      Object.keys(a2).forEach(function(e5) {
        h2.events.add(e5, a2[e5]);
      }), o3.createCluster && (h2.createCluster = o3.createCluster), h2.add(u2[e4]), i2.geoObjects.add(h2);
    }
  }), p2.length) {
    var m2 = s2 ? new ymaps.ObjectManager({ clusterize: false }) : new ymaps.GeoObjectCollection();
    p2.forEach(function(e4) {
      return m2.add(e4);
    }), i2.geoObjects.add(m2);
  }
}
function l(e3) {
  return e3.charAt(0).toUpperCase() + e3.slice(1);
}
function c(e3) {
  return (e3.icon.color || "blue") + (e3.icon.glyph ? l(e3.icon.glyph) : e3.icon.content ? "Stretchy" : "");
}
function u(e3) {
  return e3.map(function(e4) {
    return Array.isArray(e4) ? u(e4) : +e4;
  });
}
function p(e3, t2) {
  var n2 = [];
  return function e4(t3, r2) {
    if (t3 === r2)
      return true;
    if (t3 instanceof Date && r2 instanceof Date)
      return +t3 == +r2;
    if ("function" == typeof t3 && "function" == typeof r2)
      return true;
    if ("object" !== o(t3) || "object" !== o(r2))
      return false;
    if (function(e5, t4) {
      for (var o2 = n2.length; o2--; )
        if (!(n2[o2][0] !== e5 && n2[o2][0] !== t4 || n2[o2][1] !== t4 && n2[o2][1] !== e5))
          return true;
      return false;
    }(t3, r2))
      return true;
    n2.push([t3, r2]);
    var a2 = Object.keys(t3), i2 = a2.length;
    if (Object.keys(r2).length !== i2)
      return false;
    for (; i2--; )
      if (!e4(t3[a2[i2]], r2[a2[i2]]))
        return false;
    return true;
  }(e3, t2);
}
var m = new (function() {
  function e3() {
    !function(e4, t3) {
      if (!(e4 instanceof t3))
        throw new TypeError("Cannot call a class as a function");
    }(this, e3), this.events = {}, this.ymapReady = false, this.scriptIsNotAttached = true;
  }
  var t2, o2, r2;
  return t2 = e3, (o2 = [{ key: "$on", value: function(e4, t3) {
    var o3 = this;
    return this.events[e4] || (this.events[e4] = []), this.events[e4].push(t3), function() {
      o3.events[e4] = o3.events[e4].filter(function(e5) {
        return t3 !== e5;
      });
    };
  } }, { key: "$emit", value: function(e4, t3) {
    var o3 = this.events[e4];
    o3 && o3.forEach(function(e5) {
      return e5(t3);
    });
  } }]) && n(t2.prototype, o2), r2 && n(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), e3;
}())();
var d = ["fullscreenControl", "geolocationControl", "routeEditor", "rulerControl", "searchControl", "trafficControl", "typeSelector", "zoomControl", "routeButtonControl", "routePanelControl", "smallMapDefaultSet", "mediumMapDefaultSet", "largeMapDefaultSet"];
function f(e3) {
  return 0 === e3.filter(function(e4) {
    return ![].concat(d, ["default"]).includes(e4);
  }).length;
}
function y() {
  var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return new Promise(function(t2, o2) {
    if (window.ymaps)
      return t2();
    if (document.getElementById("vue-yandex-maps"))
      m.$on("scriptIsLoaded", t2);
    else {
      var n2 = document.createElement("SCRIPT"), r2 = e3.apiKey, a2 = void 0 === r2 ? "" : r2, i2 = e3.lang, s2 = void 0 === i2 ? "ru_RU" : i2, l2 = e3.version, c2 = void 0 === l2 ? "2.1" : l2, u2 = e3.coordorder, p2 = void 0 === u2 ? "latlong" : u2, d2 = e3.debug, f2 = void 0 !== d2 && d2, y2 = e3.enterprise, h2 = void 0 !== y2 && y2, b2 = f2 ? "debug" : "release", v2 = "lang=".concat(s2).concat(a2 && "&apikey=".concat(a2), "&mode=").concat(b2, "&coordorder=").concat(p2), g2 = "https://".concat(h2 ? "enterprise." : "", "api-maps.yandex.ru/").concat(c2, "/?").concat(v2);
      n2.setAttribute("src", g2), n2.setAttribute("async", ""), n2.setAttribute("defer", ""), n2.setAttribute("id", "vue-yandex-maps"), document.head.appendChild(n2), m.scriptIsNotAttached = false, n2.onload = function() {
        ymaps.ready(function() {
          m.ymapReady = true, m.$emit("scriptIsLoaded"), t2();
        });
      }, n2.onerror = o2;
    }
  });
}
var h;
var b = 1;
var v = m;
var g = ["actionend", "balloonclose", "balloonopen", "click", "contextmenu", "dblclick", "destroy", "hintclose", "hintopen", "optionschange", "sizechange", "typechange"];
var k = { pluginOptions: {}, provide: function() {
  var e3, t2, o2, n2, r2, a2, i2 = this, s2 = [], l2 = [];
  return null != this.balloonComponent && (n2 = this.balloonComponent, r2 = null, a2 = "vue-balloon-".concat(b), b += 1, o2 = function(e4, t3) {
    var o3 = ymaps.templateLayoutFactory.createClass('<div id="'.concat(a2, '"><div>'), { build: function() {
      o3.superclass.build.call(this), (r2 = new h({ parent: e4.$root, data: function() {
        return { props: e4.$props, listeners: e4.$listeners };
      }, propsData: { marker: t3, component: n2 } })).$mount("#".concat(a2));
    }, clear: function() {
      r2.$destroy(), r2 = null, o3.superclass.clear.call(this);
    } });
    return o3;
  }), { useObjectManager: this.useObjectManager, addMarker: this.addMarker, deleteMarker: function(t3) {
    i2.myMap.geoObjects && (s2.push(t3), e3 && clearTimeout(e3), e3 = setTimeout(function() {
      i2.deleteMarkers(s2), s2 = [];
    }, 0));
  }, compareValues: function(e4) {
    var o3 = e4.newVal, n3 = e4.oldVal, r3 = e4.marker;
    p(o3, n3) || (l2.push(r3), t2 && clearTimeout(t2), t2 = setTimeout(function() {
      i2.setMarkers(l2), l2 = [];
    }, 0));
  }, makeComponentBalloonTemplate: o2 };
}, data: function() {
  return { ymapId: "yandexMap".concat(Math.round(1e5 * Math.random())), style: this.ymapClass ? "" : "width: 100%; height: 100%;", isReady: false, debounce: null };
}, props: { coords: { type: Array, required: true }, zoom: { validator: function(e3) {
  return !Number.isNaN(e3);
}, default: 18 }, bounds: Array, clusterOptions: { type: Object, default: function() {
  return {};
} }, clusterCallbacks: { type: Object, default: function() {
  return {};
} }, behaviors: { type: Array, default: function() {
  return ["default"];
} }, controls: { type: Array, default: function() {
  return ["default"];
}, validator: function(e3) {
  return f(e3);
} }, detailedControls: { type: Object, validator: function(e3) {
  return f(Object.keys(e3));
} }, scrollZoom: { type: Boolean, default: true }, mapType: { type: String, default: "map", validator: function(e3) {
  return ["map", "satellite", "hybrid"].includes(e3);
} }, placemarks: { type: Array, default: function() {
  return [];
} }, useObjectManager: { type: Boolean, default: false }, objectManagerClusterize: { type: Boolean, default: true }, ymapClass: String, initWithoutMarkers: { type: Boolean, default: true }, debug: { type: Boolean, default: false }, settings: { type: Object, default: function() {
  return {};
} }, options: { type: Object, default: function() {
  return {};
} }, mapEvents: { type: Array, default: function() {
  return [];
} }, showAllMarkers: Boolean, disablePan: Boolean, balloonComponent: { type: [Object, Function], default: function() {
  return null;
} }, useHtmlInLayout: Boolean }, computed: { coordinates: function() {
  return this.coords.map(function(e3) {
    return +e3;
  });
} }, methods: { init: function() {
  var e3 = this;
  if (this.myMap = {}, this.markers = [], window.ymaps && ymaps.GeoObjectCollection && (this.initWithoutMarkers || this.$slots.default || this.placemarks.length)) {
    if (this.$emit("map-initialization-started"), this.myMap = new ymaps.Map(this.ymapId, { center: this.coordinates, zoom: +this.zoom, bounds: this.bounds, behaviors: this.behaviors, controls: this.controls, type: "yandex#".concat(this.mapType) }, this.options), (this.mapEvents.length ? this.mapEvents : g).forEach(function(t2) {
      return e3.myMap.events.add(t2, function(o2) {
        return e3.$emit(t2, o2);
      });
    }), this.myMap.events.add("boundschange", function(t2) {
      var o2 = t2.originalEvent, n2 = o2.newZoom, r2 = o2.newCenter, a2 = o2.newBounds;
      e3.$emit("boundschange", t2), e3.$emit("update:zoom", n2), e3.$emit("update:coords", r2), e3.$emit("update:bounds", a2);
    }), this.detailedControls)
      Object.keys(this.detailedControls).forEach(function(t2) {
        e3.myMap.controls.remove(t2), e3.myMap.controls.add(t2, e3.detailedControls[t2]);
      });
    false === this.scrollZoom && this.myMap.behaviors.disable("scrollZoom"), this.isReady = true, this.$emit("map-was-initialized", this.myMap);
  }
}, addMarker: function(e3) {
  var t2 = this;
  this.markers.push(e3), this.debounce && clearTimeout(this.debounce), this.debounce = setTimeout(function() {
    t2.setMarkers(t2.markers);
  }, 0);
}, setMarkers: function(e3) {
  var t2 = this, o2 = { options: this.clusterOptions, callbacks: this.clusterCallbacks, map: this.myMap, useObjectManager: this.useObjectManager, objectManagerClusterize: this.objectManagerClusterize, useHtmlInLayout: this.useHtmlInLayout };
  if (this.markers !== e3) {
    var n2 = e3.map(function(e4) {
      return t2.useObjectManager ? e4.id : e4.properties.get("markerId");
    });
    this.deleteMarkers(n2), s(e3, o2), this.$emit("markers-was-change", n2);
  } else
    s(e3, o2);
  this.markers = [], this.showAllMarkers && this.myMap.setBounds(this.myMap.geoObjects.getBounds());
}, deleteMarkers: function(e3) {
  var t2 = this, o2 = [];
  this.myMap.geoObjects.each(function(e4) {
    return o2.push(e4);
  }), o2.forEach(function(o3) {
    var n2 = [];
    if (t2.useObjectManager)
      o3.remove(e3);
    else {
      var r2, a2 = function(t3) {
        var o4 = t3.properties.get("markerId");
        e3.includes(o4) && n2.push(t3);
      };
      if (o3.each)
        o3.each(a2), r2 = o3.getLength();
      else if (o3.getGeoObjects) {
        var i2 = o3.getGeoObjects();
        i2.forEach(a2), r2 = i2.length;
      }
      0 === r2 || r2 === n2.length ? t2.myMap.geoObjects.remove(o3) : n2.length && n2.forEach(function(e4) {
        return o3.remove(e4);
      });
    }
  }), this.$emit("markers-was-delete", e3);
} }, watch: { coordinates: function(e3) {
  this.myMap && (this.disablePan ? this.myMap.setCenter && this.myMap.setCenter(e3) : this.myMap.panTo && this.myMap.getZoom() && this.myMap.panTo(e3, { checkZoomRange: true }));
}, zoom: function() {
  this.myMap && this.myMap.setZoom(this.zoom);
}, bounds: function(e3) {
  this.myMap && this.myMap.setBounds && this.myMap.setBounds(e3);
} }, render: function(e3) {
  return e3("section", { class: "ymap-container", ref: "mapContainer" }, [e3("div", { attrs: { id: this.ymapId, class: this.ymapClass, style: this.style } }), this.isReady && e3("div", [this.$slots.default])]);
}, mounted: function() {
  var e3 = this;
  if (this.$attrs["map-link"] || this.$attrs.mapLink)
    throw new Error("Vue-yandex-maps: Attribute mapLink is not supported. Use settings.");
  if (this.placemarks && this.placemarks.length)
    throw new Error("Vue-yandex-maps: Attribute placemarks is not supported. Use marker component.");
  this.mapObserver = new MutationObserver(function() {
    e3.myMap.container && e3.myMap.container.fitToViewport();
  });
  var o2 = this.$refs.mapContainer;
  if (this.mapObserver.observe(o2, { attributes: true, childList: true, characterData: true, subtree: false }), v.scriptIsNotAttached) {
    var n2 = this.debug;
    y(t(t(t({}, this.$options.pluginOptions), this.settings), {}, { debug: n2 }));
  }
  v.ymapReady ? ymaps.ready(this.init) : v.$on("scriptIsLoaded", this.init);
}, beforeDestroy: function() {
  this.myMap && this.myMap.geoObjects && this.myMap.geoObjects.removeAll();
} };
var O = ["placemark", "polyline", "rectangle", "polygon", "circle"];
var C = ["balloonclose", "balloonopen", "click", "contextmenu", "dblclick", "drag", "dragend", "dragstart", "hintclose", "hintopen", "mouseenter", "mouseleave"];
var M = { inject: ["useObjectManager", "addMarker", "deleteMarker", "compareValues", "makeComponentBalloonTemplate"], props: { coords: Array, hintContent: String, icon: Object, balloon: Object, markerType: { type: String, validator: function(e3) {
  return O.includes(e3.toLowerCase());
}, default: "placemark" }, markerFill: Object, markerStroke: Object, clusterName: [String, Number], circleRadius: { validator: function(e3) {
  return !Number.isNaN(e3);
}, default: 1e3 }, balloonTemplate: String, markerId: { type: [String, Number], required: true }, properties: Object, options: Object, balloonComponentProps: { type: Object, default: function() {
  return {};
} }, markerEvents: { type: Array, default: function() {
  return [];
} } }, data: function() {
  return { unwatchArr: [] };
}, render: function(e3) {
  return e3("div", [this.$slots.balloon && e3("div", { style: "display: none;" }, [this.$slots.balloon]), this.$slots.balloonLayout && e3("div", { style: "display: none;" }, [this.$slots.balloonLayout])]);
}, mounted: function() {
  var e3 = this;
  Object.keys(this.$props).forEach(function(t2) {
    "balloonComponentProps" !== t2 && e3.unwatchArr.push(e3.$watch(t2, function(t3, o2) {
      return e3.compareValues({ newVal: t3, oldVal: o2, marker: e3.defineMarker() });
    }));
  }), this.addMarker(this.defineMarker());
}, methods: { defineMarker: function() {
  var e3 = this, t2 = { markerId: this.markerId, markerType: this.markerType || "placemark", coords: u(this.coords), hintContent: this.hintContent, markerFill: this.markerFill, circleRadius: +this.circleRadius, clusterName: this.clusterName, markerStroke: this.markerStroke, balloon: this.balloon, properties: this.properties, options: this.options, balloonOptions: {} }, o2 = null, n2 = null;
  this.balloonTemplate && (o2 = ymaps.templateLayoutFactory.createClass(this.balloonTemplate)), this.$slots.balloon && (o2 = ymaps.templateLayoutFactory.createClass(this.$slots.balloon[0].elm.outerHTML)), this.$slots.balloonLayout && (n2 = ymaps.templateLayoutFactory.createClass(this.$slots.balloonLayout[0].elm.outerHTML)), this.makeComponentBalloonTemplate && (o2 = this.makeComponentBalloonTemplate(this, t2)), null != o2 && (t2.balloonOptions.balloonContentLayout = o2), null != n2 && (t2.balloonOptions.balloonLayout = n2), this.icon && ["default#image", "default#imageWithContent"].includes(this.icon.layout) ? (t2.iconContent = this.icon.content, t2.iconLayout = this.icon.layout, t2.iconImageHref = this.icon.imageHref, t2.iconImageSize = this.icon.imageSize, t2.iconImageOffset = this.icon.imageOffset, t2.iconContentOffset = this.icon.contentOffset, this.icon.contentLayout && "string" == typeof this.icon.contentLayout && (t2.iconContentLayout = ymaps.templateLayoutFactory.createClass(this.icon.contentLayout))) : t2.icon = this.icon;
  var r2 = function(e4, t3) {
    var o3 = l(e4);
    if (!t3)
      return o3;
    switch (o3) {
      case "Placemark":
        return "Point";
      case "Polyline":
        return "LineString";
      default:
        return o3;
    }
  }(t2.markerType, this.useObjectManager), a2 = { hintContent: t2.hintContent, iconContent: t2.icon ? t2.icon.content : t2.iconContent, markerId: t2.markerId }, i2 = t2.balloon ? { balloonContentHeader: t2.balloon.header, balloonContentBody: t2.balloon.body, balloonContentFooter: t2.balloon.footer } : {}, s2 = Object.assign(a2, i2, t2.properties), p2 = t2.iconLayout ? { iconLayout: t2.iconLayout, iconImageHref: t2.iconImageHref, iconImageSize: t2.iconImageSize, iconImageOffset: t2.iconImageOffset, iconContentOffset: t2.iconContentOffset, iconContentLayout: t2.iconContentLayout } : { preset: t2.icon && "islands#".concat(c(t2), "Icon") }, m2 = t2.markerStroke ? { strokeColor: t2.markerStroke.color || "0066ffff", strokeOpacity: parseFloat(t2.markerStroke.opacity) >= 0 ? parseFloat(t2.markerStroke.opacity) : 1, strokeStyle: t2.markerStroke.style, strokeWidth: parseFloat(t2.markerStroke.width) >= 0 ? parseFloat(t2.markerStroke.width) : 1 } : {}, d2 = t2.markerFill ? { fill: t2.markerFill.enabled || true, fillColor: t2.markerFill.color || "0066ff99", fillOpacity: parseFloat(t2.markerFill.opacity) >= 0 ? parseFloat(t2.markerFill.opacity) : 1, fillImageHref: t2.markerFill.imageHref || "" } : {}, f2 = Object.assign(p2, m2, d2, t2.balloonOptions, t2.options);
  "Circle" === r2 && (t2.coords = [t2.coords, t2.circleRadius]);
  var y2 = function(e4, t3) {
    var o3 = t3 ? { type: "Feature", id: e4.properties.markerId, geometry: { type: e4.markerType, coordinates: e4.coords }, properties: e4.properties, options: e4.options } : new ymaps[e4.markerType](e4.coords, e4.properties, e4.options);
    return o3.clusterName = e4.clusterName, o3;
  }({ properties: s2, options: f2, markerType: r2, coords: t2.coords, clusterName: t2.clusterName }, this.useObjectManager, this.$emit);
  this.useObjectManager || (this.markerEvents.length ? this.markerEvents : C).forEach(function(t3) {
    return y2.events.add(t3, function(o3) {
      return e3.$emit(t3, o3);
    });
  });
  return y2;
} }, beforeDestroy: function() {
  this.unwatchArr.forEach(function(e3) {
    return e3();
  }), this.deleteMarker(this.markerId);
} };
k.install = function e2(t2) {
  var o2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  e2.installed || (3 != +t2.version[0] ? (e2.installed = true, function(e3) {
    "function" == typeof e3.extend && (h = e3.extend({ props: ["marker", "component"], template: '<component :is="component" v-bind="{ marker, ...props.balloonComponentProps }" v-on="listeners" />' }));
  }(t2), k.pluginOptions = o2, t2.component("yandex-map", k), t2.component("ymap-marker", M)) : console.warn("Vue-yandex-maps: This version is only compatible with Vue 2.X. Please install vue-yandex-maps@next"));
}, "undefined" != typeof window && window.Vue && window.Vue.use(k);
var j = y;
var w = k;
var L = M;
var vue_yandex_maps_esm_default = k;

// dep:vue-yandex-maps
var vue_yandex_maps_default = vue_yandex_maps_esm_default;
export {
  vue_yandex_maps_default as default,
  j as loadYmap,
  w as yandexMap,
  L as ymapMarker
};
//# sourceMappingURL=vue-yandex-maps.js.map
